# nanoFramework.Test
This repository is a try to implement a unit testing framework for the nanoFramework.
## Idea
I general it would be good to have unit tests for each nanoFramework library method. To archive this a test assembly can be made each library.
### Inside the nanoFramework device - implemented in nanoFramework C#
For the mscorlib; the base library the first tests are implemented in [nanoFramework.CoreLibrary.Tests](https://github.com/MatthiasJentsch/nanoFramework.Test/tree/master/nanoFramework.CoreLibrary.Tests). Each test assembly uses the [nanoFramework.Test.Engine](https://github.com/MatthiasJentsch/nanoFramework.Test/tree/master/nanoFramework.Test.Engine). The test assembly has the Main function and calls `TestManager.RunTests(Assembly.GetExecutingAssembly());`. That discovers all tests in the test assembly and executes them. The progress of the test execution will be reported via `Console.WriteLine` to a connected host computer.
### At the host computer - implemented in C# for .NET 4.7
The host computer runs the [nanoFramework.Tools.UnitTester](https://github.com/MatthiasJentsch/nanoFramework.Test/tree/master/nanoFramework.Tools.UnitTester). This program reads a file from a configured directory. This file contains what should be done. It describes the "job" that should be done and contains on which device type which firmware with which test library should be executed. The job file is in JSON format. After all tests are executed the result will be written as file also in JSON format.
### At a test manager computer - implemented in C# for .NET Core 2.1
There is an additional piece of software: [nanoFramework.Tools.UnitTestManager](https://github.com/MatthiasJentsch/nanoFramework.Test/tree/master/nanoFramework.Tools.UnitTestManager) This are web services that can be run for instance on a Raspberry Pi. It supports three services:
* http://<serviceHost>/discovery for getting a list of test hardware
* http://<serviceHost>/start/<deviceType> for starting a test on one device. If the test could be started it delivers a test ID (a GUID). With that test ID the results can be get from the third service
* http://<serviceHost>/result/<testID> for getting the results of a test

The UnitTestManager knowns all devices that are connected to the host computer. The host computer can be in sleep mode if no test is executed. The UnitTestManager can wake up the host computer via wake-on-lan.
## Test procedure
A build server can discover the available test hardware with the UnitTestManager discovery service. If one test device is available the build server can start a test run via UnitTestManager start service. The result of this start is a test ID. Also an estimated test execution duration is delivered. The build server should now wait and start polling the test results after the estimated execution duration is over. With the UnitTestManager result service, the build server can get the test results.

During start of the test run the UnitTestManager has written the job file for the UnitTester and did optionally the wake-on-lan for the host computer where the UnitTester runs. The UnitTester finds the job file and downloads the current nanoCLR firmware for the device. After download it flashes the test device with that firmware. For the ESP32 that will be done with the [EspFirmwareFlasher](https://github.com/nanoframework/nf-tools/tree/master/EspFirmwareFlasher). After that the nuget package for the [nf-debugger](https://github.com/nanoframework/nf-debugger) will be downloaded. Also all dependencies for the test assemblies and the test assemblies will be downloaded. If all downloads has finished successfully the UnitTester connects via nf-debugger to the test device and deploys the test assembly with all it's dependencies. Then it reboots the device and capture the Console.WriteLine outputs from the test device. It wraps these test results that the device outputs into JSON notation and writes it as test result into a file. Ready for the polling via build server and UnitTestManager.